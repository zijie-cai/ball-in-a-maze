function resetGame(generateNewMaze = false) {
    previousTimestamp = undefined;
    gameInProgress = false;
    isMouseDown = false;
    mouseStartX = undefined;
    mouseStartY = undefined;
    accelerationX = 0;
    accelerationY = 0;
    frictionX = 0;
    frictionY = 0;
    currentRotationX = 0;
    currentRotationY = 0;
    tiltRotationX = 0;
    tiltRotationY = 0;

    mazeElement.style.transform = `
        rotateY(0deg) rotateX(0deg)
    `;

    // Reset all maze borders to grey
    mazeElement.style.borderTop = '2px solid #ccc';
    mazeElement.style.borderBottom = '2px solid #ccc';
    mazeElement.style.borderLeft = '2px solid #ccc';
    mazeElement.style.borderRight = '2px solid #ccc';

    joystickHeadElement.style.cssText = `
        left: 0;
        top: 0;
        animation: glow 0.6s infinite alternate ease-in-out;
        cursor: grab;
        position: relative;
    `;
    startJoystickGlow(); // Ensure glow animation is active

    // Remove the automatic display of the instruction modal
    // instructionModal.style.display = "block";

    // Hide any existing toast
    toast.className = "";

    // Clear existing messages
    noteElement.innerHTML = ``;
    noteElement.style.opacity = 0;

    // Clear previous ball elements
    if (ballElements.length) {
        ballElements.forEach((ballElement) => {
            mazeElement.removeChild(ballElement);
        });
        ballElements = [];
    }

    // Clear previous wall elements
    if (wallElements.length) {
        wallElements.forEach((wallElement) => {
            mazeElement.removeChild(wallElement);
        });
        wallElements = [];
    }

    // Fixed starting position
    const ballStart = { column: mazeColumns-1, row: mazeRows-1};

    // Fixed exit side and exit cell (Bottom-Left Corner)
    exitSide = 'left';
    exitCell = { column: 0, row: Math.floor(mazeRows / 2) };

    const ballStartX = ballStart.column * (wallW + pathW) + (wallW / 2 + pathW / 2);
    const ballStartY = ballStart.row * (wallW + pathW) + (wallW / 2 + pathW / 2);

    balls = [{
        x: ballStartX,
        y: ballStartY,
        velocityX: 0,
        velocityY: 0
    }];

    // Draw the ball
    balls.forEach(({ x, y }) => {
        const ball = document.createElement("div");
        ball.setAttribute("class", "ball");
        ball.style.cssText = `left: ${x}px; top: ${y}px; `;

        mazeElement.appendChild(ball);
        ballElements.push(ball);
    });

    if (generateNewMaze) {
        generateMaze();
    } else {
        // Draw walls
        walls.forEach(({ x, y, horizontal, length }) => {
            const wall = document.createElement("div");
            wall.setAttribute("class", "wall");
            wall.style.cssText = `
                left: ${x}px;
                top: ${y}px;
                width: ${wallW}px;
                height: ${length}px;
                transform: rotate(${horizontal ? -90 : 0}deg);
            `;

            mazeElement.appendChild(wall);
            wallElements.push(wall);
        });

        // Highlight the exit border
        highlightExitBorder();
    }
}
